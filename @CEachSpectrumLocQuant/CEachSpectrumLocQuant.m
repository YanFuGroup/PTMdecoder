classdef CEachSpectrumLocQuant
    % Class for processing a single spectrum, using the core model for discrimination and quantification
    
    properties
        m_pepSeq;             % peptide sequence
        m_isProtN;            % whether it is protein N-terminus
        m_isProtC;            % whether it is protein C-terminus
        m_cMgfDatasetIO;      % spectrum IO
        m_strDatasetName;     % dataset name
        m_strSpecName;        % spectrum name
        m_fixedModNameMass;   % list of fixed modifications "name-mass"
        m_variableModNameMass;% list of variable modifications "name-mass"
        m_model;              % three models generated by three fragmentation efficiency assumptions: variable, constant but unequal, and equal to 1
        m_method;             % estimation method: OLS or lasso
        m_lambda;             % lasso penalty parameter
        m_ms1_tolerance;      % the mass tolerance of MS1
        m_ms2_tolerance;      % the mass tolerance of MS2
        m_alpha;              % relative intensity coefficient for denoising
        m_resFilterThres;     % threshold for filtering results by relative intensity
        m_ionTypes;           % types of used fragment ions (b/y)
        m_enzyme;             % enzyme

        m_case_penalty_intens; % penalty intensity mode for SDP/KSDP/hyperscore
        m_grid_penalty_intens; % penalty intensity mode inside KSDP grid
        m_case_OLS_intens_weight; % OLS intensity weighting mode for X matrix

        m_iCharge;          % spectrum charge
        m_dPrecursorMass;   % neutral mass of precursor ion
        m_expPeaks          % all spectrum peaks, each row is a peak: left is m/z, right is intensity
    end

    methods
        function obj = CEachSpectrumLocQuant(pepSeq,isProtN,isProtC, ...
            cMgfDatasetIO,strDatasetName,strSpecName,fixedModNameMass, ...
            variableModNameMass,model,method,lambda,ms1_tolerance,ms2_tolerance,...
            alpha,resFilterThres,ionTypes,enzyme,case_penalty_intens,grid_penalty_intens,case_OLS_intens_weight)
            % Input:
            %   pepSeq (1 x 1 char/string)
            %       peptide sequence
            %   isProtN (1 x 1 logical)
            %       whether peptide is protein N-terminus
            %   isProtC (1 x 1 logical)
            %       whether peptide is protein C-terminus
            %   cMgfDatasetIO (CMgfDatasetIO)
            %       spectrum IO instance
            %   strDatasetName (1 x 1 char/string)
            %       dataset name
            %   strSpecName (1 x 1 char/string)
            %       spectrum name
            %   fixedModNameMass (M x 3 cell)
            %       fixed modification name/site/mass list
            %   variableModNameMass (M x 3 cell)
            %       variable modification name/site/mass list
            %   model (1 x 1 double/int)
            %       model index
            %   method (1 x 1 double/int)
            %       estimation method
            %   lambda (1 x 1 double)
            %       lasso penalty parameter
            %   ms1_tolerance (struct)
            %       MS1 tolerance (fields: value, isppm)
            %   ms2_tolerance (struct)
            %       MS2 tolerance (fields: value, isppm)
            %   alpha (1 x 1 double)
            %       denoising threshold factor
            %   resFilterThres (1 x 1 double)
            %       result filter threshold
            %   ionTypes (1 x T double/int)
            %       ion types for matching
            %   enzyme (struct)
            %       enzyme settings
            %   case_penalty_intens (1 x 1 char/string, optional)
            %       penalty intensity mode for SDP/KSDP/hyperscore
            %   grid_penalty_intens (1 x 1 char/string, optional)
            %       intensity aggregation mode inside KSDP grid
            %   case_OLS_intens_weight (1 x 1 char/string, optional)
            %       OLS intensity weighting mode for X matrix
            obj.m_pepSeq = pepSeq;
            obj.m_isProtN = isProtN;
            obj.m_isProtC = isProtC;
            obj.m_cMgfDatasetIO = cMgfDatasetIO;
            obj.m_strDatasetName = strDatasetName;
            obj.m_strSpecName = strSpecName;
            obj.m_fixedModNameMass = fixedModNameMass;
            obj.m_variableModNameMass = variableModNameMass;
            obj.m_model = model;
            obj.m_method = method;
            obj.m_lambda = lambda;
            obj.m_ms1_tolerance = ms1_tolerance;
            obj.m_ms2_tolerance = ms2_tolerance;
            obj.m_alpha = alpha;
            obj.m_resFilterThres = resFilterThres;
            obj.m_ionTypes = ionTypes;
            obj.m_enzyme = enzyme;

            if nargin < 18 || isempty(case_penalty_intens)
                obj.m_case_penalty_intens = 'intens_sum';
            else
                obj.m_case_penalty_intens = case_penalty_intens;
            end
            if nargin < 19 || isempty(grid_penalty_intens)
                obj.m_grid_penalty_intens = 'intens_sum';
            else
                obj.m_grid_penalty_intens = grid_penalty_intens;
            end
            if nargin < 20 || isempty(case_OLS_intens_weight)
                obj.m_case_OLS_intens_weight = 'none';
            else
                obj.m_case_OLS_intens_weight = case_OLS_intens_weight;
            end
        end
        
        % Main entry
        [bSuccess,str,strRatio,ionTypePosCharge,ionIntens,frageff,warning_msg,is_X_full_column_rank] = runEach(obj);

        % Calculate all possible modification configurations, given as mass arrangements
        [bSuccess,inxSites,massArrangement,warning_msg] = getMassArrangement(obj,fixedPosMod);

        % Calculate neutral peptide mass
        [m_vTheoryMass] = getNeutralPeptideTheoryMass(obj,fixedPosMod);

        % Calculate by ion m/z without variable modifications
        theoryMz = calculateIonMz(obj,fixedPosMod);

        % Find the positions of user-specified fixed modifications on the sequence
        [fixedPosMod] = getFixedPosMod(obj);

        % Organize all non-redundant ions (site-discriminating ions) and corresponding information, return [detailed information of each ion]
        [vNonRedunTheoryIonMz]  =  getNonRedunIons(obj,modSites,massArrangement,fixedPosMod);

        % Find the union of experimental peaks that can be matched by m/z
        [vMatchedExpPeaks] = match(obj,expPeaks,vNonRedunTheoryIonMz);

        % Record identification and quantification results as strings
        [cStr] = massArraTostr(obj,massArrangement,fixedPosMod,dictVariMod,inxSites);
    end
end
