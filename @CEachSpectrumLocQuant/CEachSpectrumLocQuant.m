classdef CEachSpectrumLocQuant
    % Class for processing a single spectrum, using the core model for discrimination and quantification
    
    properties
        m_pepSeq;             % peptide sequence
        m_isProtN;            % whether it is protein N-terminus
        m_isProtC;            % whether it is protein C-terminus
        m_cMgfDatasetIO;      % spectrum IO
        m_strDatasetName;     % dataset name
        m_strSpecName;        % spectrum name
        m_fixedModNameMass;   % list of fixed modifications "name-mass"
        m_variableModNameMass;% list of variable modifications "name-mass"
        m_model;              % three models generated by three fragmentation efficiency assumptions: variable, constant but unequal, and equal to 1
        m_method;             % estimation method: OLS or lasso
        m_lambda;             % lasso penalty parameter
        m_ms1_tolerance;      % the mass tolerance of MS1
        m_ms2_tolerance;      % the mass tolerance of MS2
        m_alpha;              % relative intensity coefficient for denoising
        m_resFilterThres;     % threshold for filtering results by relative intensity
        m_ionTypes;           % types of used fragment ions (b/y)
        m_enzyme;             % enzyme

        m_iCharge;          % spectrum charge
        m_dPrecursorMass;   % neutral mass of precursor ion
        m_expPeaks          % all spectrum peaks, each row is a peak: left is m/z, right is intensity
    end

    methods
        function obj = CEachSpectrumLocQuant(pepSeq,isProtN,isProtC, ...
                cMgfDatasetIO,strDatasetName,strSpecName,fixedModNameMass, ...
                variableModNameMass,model,method,lambda,ms1_tolerance,ms2_tolerance,...
                alpha,resFilterThres,ionTypes,enzyme)
            obj.m_pepSeq = pepSeq;
            obj.m_isProtN = isProtN;
            obj.m_isProtC = isProtC;
            obj.m_cMgfDatasetIO = cMgfDatasetIO;
            obj.m_strDatasetName = strDatasetName;
            obj.m_strSpecName = strSpecName;
            obj.m_fixedModNameMass = fixedModNameMass;
            obj.m_variableModNameMass = variableModNameMass;
            obj.m_model = model;
            obj.m_method = method;
            obj.m_lambda = lambda;
            obj.m_ms1_tolerance = ms1_tolerance;
            obj.m_ms2_tolerance = ms2_tolerance;
            obj.m_alpha = alpha;
            obj.m_resFilterThres = resFilterThres;
            obj.m_ionTypes = ionTypes;
            obj.m_enzyme = enzyme;
        end
        
        % Main entry
        [bSuccess,str,strRatio,ionTypePosCharge,ionIntens,frageff,warning_msg,is_X_full_column_rank] = runEach(obj);

        % Calculate all possible modification configurations, given as mass arrangements
        [bSuccess,inxSites,massArrangement,warning_msg] = getMassArrangement(obj,fixedPosMod);

        % Calculate neutral peptide mass
        [m_vTheoryMass] = getNeutralPeptideTheoryMass(obj,fixedPosMod);

        % Calculate by ion m/z without variable modifications
        theoryMz = calculateIonMz(obj,fixedPosMod);

        % Find the positions of user-specified fixed modifications on the sequence
        [fixedPosMod] = getFixedPosMod(obj);

        % Organize all non-redundant ions (site-discriminating ions) and corresponding information, return [detailed information of each ion]
        [vNonRedunTheoryIonMz]  =  getNonRedunIons(obj,modSites,massArrangement,fixedPosMod);

        % Find the union of experimental peaks that can be matched by m/z
        [vMatchedExpPeaks] = match(obj,expPeaks,vNonRedunTheoryIonMz);

        % Record identification and quantification results as strings
        [cStr] = massArraTostr(obj,massArrangement,fixedPosMod,dictVariMod,inxSites);
    end
end
